# Batch Operations with Transaction Management

Write mutations that handle bulk operations while respecting transaction limits. This will test your understanding of:
1. Batch processing
2. Transaction boundaries
3. Error handling and rollback
4. Progress tracking

## Schema

Create a schema with these tables:

1. "products" table:
   - `name`: string (required) - Product name
   - `price`: number (required) - Price in cents
   - `stock`: number (required) - Current stock level
   - `category`: string (required) - Product category
   - `discontinued`: boolean (required) - Whether product is discontinued

2. "stockUpdates" table:
   - `productId`: Id<"products"> (required) - Reference to product
   - `quantity`: number (required) - Change in stock (positive or negative)
   - `timestamp`: number (required) - When update occurred
   - `status`: string (required) - One of: "pending", "applied", "failed"
   - `error`: string (optional) - Error message if failed

## Required Functions

1. Write a mutation called `batchDiscontinueProducts` that:
   - Takes an array of product IDs
   - Marks all products as discontinued
   - Updates their stock to 0
   - Returns count of updated products
   - Handles partial failures

2. Write a mutation called `batchUpdateStock` that:
   - Takes an array of updates: { productId, quantity }[]
   - Creates stockUpdate records
   - Applies updates to product stock
   - Handles validation and rollback
   - Returns results per update

## Example Usage

```typescript
// Discontinue products
const result = await client.mutation("batchDiscontinueProducts", {
  productIds: [id1, id2, id3]
});
// Returns: { updated: 3, failed: 0 }

// Update stock levels
const updates = await client.mutation("batchUpdateStock", {
  updates: [
    { productId: id1, quantity: 5 },
    { productId: id2, quantity: -3 },
    { productId: id3, quantity: 10 }
  ]
});
// Returns: [
//   { productId: id1, success: true, newStock: 15 },
//   { productId: id2, success: true, newStock: 7 },
//   { productId: id3, success: true, newStock: 20 }
// ]
```

## Implementation Requirements

1. Transaction Safety:
   - Handle Convex's transaction limits
   - Process in smaller batches if needed
   - Maintain consistency across tables

2. Validation Rules:
   - Stock cannot go negative
   - Cannot update discontinued products
   - Quantity changes must be whole numbers

3. Error Handling:
   - Track failed operations
   - Continue processing on partial failures
   - Provide detailed error messages
   - Roll back related changes on failure

4. Performance:
   - Use appropriate indexes
   - Minimize database operations
   - Handle large batches efficiently

## Test Cases

Your implementation should handle:

1. Basic Operations:
   - Successful bulk discontinue
   - Successful stock updates
   - Mixed success/failure batches

2. Validation Errors:
   - Invalid product IDs
   - Insufficient stock
   - Updates to discontinued products

3. Transaction Limits:
   - Large batches (>100 items)
   - Multiple table updates
   - Partial batch completion

4. Concurrency:
   - Parallel stock updates
   - Race conditions
   - Consistent final state

5. Error Recovery:
   - Partial failures
   - Cleanup of failed updates
   - Accurate status tracking