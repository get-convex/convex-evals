# Cascading Updates Across Related Tables

Write mutations that handle cascading updates in a project management system. This will test your understanding of:
1. Related table updates
2. Referential integrity
3. Transaction consistency
4. Update propagation

## Schema

Create a schema with these tables:

1. "projects" table:
   - `name`: string (required) - Project name
   - `status`: string (required) - One of: "active", "paused", "completed", "archived"
   - `ownerId`: Id<"users"> (required) - Project owner
   - `budget`: number (required) - Project budget in cents
   - `startDate`: number (required) - Project start date
   - `endDate`: number (optional) - Project end date
   - `archived`: boolean (required) - Whether project is archived

2. "tasks" table:
   - `projectId`: Id<"projects"> (required) - Parent project
   - `title`: string (required) - Task title
   - `status`: string (required) - One of: "todo", "in_progress", "blocked", "completed"
   - `assigneeId`: Id<"users"> (optional) - Assigned user
   - `budget`: number (required) - Task budget in cents
   - `dueDate`: number (optional) - Task due date
   - `archived`: boolean (required) - Whether task is archived

3. "timeEntries" table:
   - `taskId`: Id<"tasks"> (required) - Related task
   - `userId`: Id<"users"> (required) - User who logged time
   - `duration`: number (required) - Duration in minutes
   - `date`: number (required) - Entry date
   - `billable`: boolean (required) - Whether time is billable
   - `rate`: number (required) - Billing rate in cents per hour

4. "users" table:
   - `name`: string (required) - User name
   - `role`: string (required) - One of: "member", "manager", "admin"
   - `defaultRate`: number (required) - Default billing rate
   - `active`: boolean (required) - Whether user is active

## Required Functions

Write a mutation called `archiveProject` that:

1. Takes these arguments:
   - `projectId`: Id<"projects"> - Project to archive
   - `archiveReason`: string - Why the project is being archived
   - `preserveTimeEntries`: boolean - Whether to keep time entries

2. Updates that cascade:
   - Mark project as archived
   - Archive all tasks in the project
   - Handle time entries based on preserveTimeEntries flag
   - Update project status to "archived"
   - Set project end date if not set

3. Validation rules:
   - Only managers/admins can archive projects
   - Cannot archive already archived projects
   - All billable time must be invoiced
   - Tasks must be completed or archived

4. Returns:
   - Updated project document
   - Count of affected tasks
   - Total archived time entries
   - Summary of changes

## Example Usage

```typescript
// Success case
const result = await client.mutation("archiveProject", {
  projectId: existingId,
  archiveReason: "Project completed",
  preserveTimeEntries: true
});
// Returns: {
//   project: { status: "archived", archived: true, ... },
//   archivedTasks: 5,
//   archivedTimeEntries: 0,  // preserved
//   changes: {
//     tasks: ["Archived 5 tasks"],
//     timeEntries: ["Preserved 25 time entries"]
//   }
// }

// Error case - incomplete tasks
await client.mutation("archiveProject", {
  projectId: projectWithActiveTasks,
  archiveReason: "Early termination",
  preserveTimeEntries: false
}); 
// Throws: "Cannot archive project with incomplete tasks"
```

## Test Cases

Your implementation should handle:

1. Basic Archival:
   - Project status update
   - Task archival
   - Time entry handling
   - End date setting

2. Validation:
   - Permission checks
   - Task completion checks
   - Billable time checks
   - Already archived checks

3. Cascading Updates:
   - All related tasks
   - All time entries
   - Proper order of operations
   - Transaction consistency

4. Data Preservation:
   - Time entry retention
   - Historical data
   - Audit trail

5. Error Cases:
   - Missing permissions
   - Invalid state transitions
   - Incomplete prerequisites
   - Transaction rollback