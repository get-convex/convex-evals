Create an HTTP action that handles file uploads with progress tracking and validation.

Required Action:
Create an HTTP action at `/upload` that:
1. Handles multipart/form-data uploads:
   - File data streaming
   - Metadata extraction
   - Progress tracking
   - Chunked upload support
2. Implements file validation:
   - File size limits
   - Allowed file types
   - Content validation
   - Malware scanning simulation
3. Manages upload state:
   - Upload progress
   - Validation status
   - Processing state
   - Final storage location

Schema Requirements:
- Table: "files"
  - filename: string
  - mimeType: string
  - size: number
  - uploadedBy: string
  - uploadedAt: number
  - status: union("uploading", "validating", "processing", "completed", "failed")
  - storageId: optional string
  - error: optional string
  - metadata: object with:
    - contentType: string
    - lastModified: number
    - checksum: string

- Table: "upload_chunks"
  - fileId: id("files")
  - chunkIndex: number
  - size: number
  - status: union("pending", "uploaded")
  - uploadedAt: optional number

Configuration:
```typescript
const UPLOAD_CONFIG = {
  maxFileSize: 100 * 1024 * 1024,    // 100MB
  chunkSize: 5 * 1024 * 1024,        // 5MB chunks
  allowedTypes: [
    "image/jpeg",
    "image/png",
    "image/gif",
    "application/pdf",
    "text/plain"
  ],
  validationTimeoutMs: 30000,        // 30 seconds
  processingTimeoutMs: 60000,        // 60 seconds
  maxConcurrentUploads: 3
};
```

Example Usage:
```typescript
// Initialize upload
const response = await fetch("/upload/init", {
  method: "POST",
  headers: { "Content-Type": "application/json" },
  body: JSON.stringify({
    filename: "example.pdf",
    size: 1024567,
    type: "application/pdf",
    metadata: {
      lastModified: 1678901234567
    }
  })
});

const { fileId, uploadUrls } = await response.json();

// Upload chunks
for (let i = 0; i < uploadUrls.length; i++) {
  const chunk = file.slice(i * UPLOAD_CONFIG.chunkSize, (i + 1) * UPLOAD_CONFIG.chunkSize);
  await fetch(uploadUrls[i], {
    method: "PUT",
    body: chunk
  });
}

// Complete upload
await fetch(`/upload/${fileId}/complete`, {
  method: "POST"
});

// Check status
const status = await fetch(`/upload/${fileId}/status`);
const { state, progress } = await status.json();
```

Test Cases:
1. Basic Upload Flow
   - Upload initialization
   - Chunk uploading
   - Upload completion
   - Status checking

2. Validation
   - File size limits
   - MIME type checking
   - Content validation
   - Malware scanning

3. Error Handling
   - Invalid file types
   - Oversized files
   - Corrupted chunks
   - Timeout handling

4. Concurrency
   - Multiple uploads
   - Parallel chunks
   - Resource limits
   - Progress tracking

5. Edge Cases
   - Zero-byte files
   - Maximum file size
   - Invalid chunks
   - Incomplete uploads